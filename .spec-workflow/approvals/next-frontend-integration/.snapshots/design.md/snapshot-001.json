{
  "id": "snapshot_1760807319096_hyfmrd125",
  "approvalId": "approval_1760807319093_l7v5gve2o",
  "approvalTitle": "Next.js Frontend Integration - Design Document",
  "version": 1,
  "timestamp": "2025-10-18T17:08:39.096Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Next.js Frontend Integration\n\n## Overview\n\nThis design document defines the technical architecture for integrating the Next.js 14 frontend application with the Spring Boot modular monolith backend. The integration creates a unified full-stack bookstore application while maintaining the independence and architectural principles of both systems.\n\n### Key Design Goals\n- **Seamless API Integration**: Type-safe communication between Next.js frontend and Spring Boot REST APIs\n- **Development Independence**: Frontend and backend can be developed, tested, and deployed independently\n- **Production Efficiency**: Single JAR deployment with embedded frontend assets\n- **Type Safety**: End-to-end type safety from database to UI through OpenAPI-generated types\n- **Session Management**: Distributed session handling via Hazelcast for stateful cart operations\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Backend**: Spring Boot 3.5.5, Java 21, Spring Modulith 1.4.3\n- **Frontend**: Next.js 14 (App Router), TypeScript strict mode, React 18\n- **API Contract**: OpenAPI 3.0 with Springdoc OpenAPI\n- **Build System**: Maven with frontend-maven-plugin for unified builds\n- **Session Store**: Hazelcast for distributed HTTP sessions\n\n### Project Structure (structure.md)\n- **Backend Modules**: `src/main/java/com/sivalabs/bookstore/{catalog,orders,inventory,notifications,web}`\n- **Frontend Location**: `frontend-nuxt/` directory (contains Next.js, not Nuxt despite directory name)\n- **Static Resources**: `src/main/resources/static/` for production frontend assets\n- **OpenAPI Config**: `src/main/java/com/sivalabs/bookstore/config/OpenApiConfig.java`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n#### Backend Components\n- **REST Controllers**:\n  - `ProductRestController` (`/api/products`) - catalog queries with OpenAPI annotations\n  - `CartRestController` (`/api/cart`) - session-based cart management\n  - `OrdersRestController` (`/api/orders`) - order creation and retrieval\n\n- **OpenAPI Configuration**:\n  - `OpenApiConfig.java` - provides programmatic OpenAPI customization\n  - Springdoc already configured with API groups (catalog, cart, orders)\n  - Swagger UI available at `/swagger-ui.html`\n\n- **Session Management**:\n  - `HttpSession` used in `CartRestController` for stateful cart\n  - Hazelcast distributed session store already configured\n  - `CartUtil.getCart(session)` and `CartUtil.setCart(session, cart)` utilities\n\n#### Frontend Components\n- **HTTP Client**: `apps/web/lib/http.ts` - basic GET/POST client (needs enhancement)\n- **TanStack Query**: Already configured for server state management\n- **MSW Mocks**: Mock Service Worker setup in `apps/web/mocks/` for API mocking\n- **Feature Modules**: Existing structure in `apps/web/features/{books,cart,orders}/`\n\n### Integration Points\n- **OpenAPI Endpoint**: `/api-docs` (backend serves JSON spec)\n- **Type Generation**: `openapi-typescript` tool generates `openapi.d.ts` from spec\n- **CORS**: Needs configuration for `localhost:3000` in development profile\n- **Static Assets**: Spring Boot's `ResourceHandlerRegistry` serves frontend from `/` path\n\n## Authentication and Authorization Strategy\n\n### Phase 1: Anonymous Sessions Only\nThe initial integration phase uses **anonymous sessions** for cart management without user authentication. This aligns with Requirement 12 which states \"Full authentication (login/register) is marked for Phase 2; initial release uses anonymous sessions only.\"\n\n**Session Flow**:\n1. User visits application → Spring Boot creates anonymous session → Session ID cookie sent to browser\n2. Cart operations use session ID automatically (via `credentials: 'include'`)\n3. Session stored in Hazelcast for distribution across instances\n4. Session timeout: 30 minutes\n\n### Phase 2: User Authentication (Future)\nPlanned for future release:\n- **Authentication Method**: Session-based authentication with username/password\n- **Protected Routes**: Order history, user profile\n- **Frontend Implementation**: Login/register pages, protected route guards\n- **Backend Implementation**: Spring Security with form login\n\n**Note**: Current design focuses on Phase 1 (anonymous sessions). Authentication details will be specified in a separate design document when Phase 2 begins.\n\n## Architecture\n\n### Component Interaction Diagram\n\n```mermaid\nsequenceDiagram\n    participant B as Browser\n    participant N as Next.js App\n    participant H as HTTP Client\n    participant C as CORS Filter\n    participant R as REST Controller\n    participant S as Service Layer\n    participant D as Database\n    participant HZ as Hazelcast\n\n    B->>N: GET /products\n    N->>H: useProducts(page=1)\n    H->>C: GET /api/products?page=1<br/>(credentials: include)\n    C->>C: Validate CORS<br/>(localhost:3000 allowed)\n    C->>R: Forward request<br/>(session cookie)\n    R->>HZ: Check session\n    HZ-->>R: Session data\n    R->>S: getProducts(page)\n    S->>D: Query products\n    D-->>S: Product entities\n    S-->>R: PagedResult<Product>\n    R->>R: Map to ProductDto\n    R-->>H: JSON response<br/>(200 OK)\n    H->>H: Parse & type check\n    H-->>N: Typed ProductDto[]\n    N->>N: React Query cache\n    N-->>B: Rendered product list\n```\n\n### System Architecture Diagram\n\n```mermaid\ngraph TB\n    subgraph \"Development Environment\"\n        FE[Next.js Dev Server<br/>localhost:3000]\n        BE[Spring Boot Backend<br/>localhost:8080]\n        FE -->|CORS-enabled API calls| BE\n    end\n\n    subgraph \"Production Environment\"\n        JAR[Spring Boot JAR]\n        subgraph \"Embedded in JAR\"\n            STATIC[Static Frontend Assets<br/>/_next/static/*]\n            API[REST APIs<br/>/api/*]\n        end\n        JAR --> STATIC\n        JAR --> API\n    end\n\n    subgraph \"External Services\"\n        PG[(PostgreSQL)]\n        RMQ[RabbitMQ]\n        HZ[Hazelcast]\n    end\n\n    BE --> PG\n    BE --> RMQ\n    BE --> HZ\n    API --> PG\n    API --> HZ\n\n    Browser[Browser] -->|/| STATIC\n    Browser -->|API Requests| API\n```\n\n### Build and Deployment Flow\n\n```mermaid\nsequenceDiagram\n    participant Dev as Developer\n    participant Maven as Maven Build\n    participant FMP as frontend-maven-plugin\n    participant Next as Next.js Build\n    participant Spring as Spring Boot\n\n    Dev->>Maven: ./mvnw clean package\n    Maven->>FMP: Execute frontend build phase\n    FMP->>FMP: Install Node.js & pnpm\n    FMP->>Next: pnpm install & pnpm build\n    Next->>Next: Build optimized bundle\n    Next-->>FMP: .next/standalone + .next/static\n    FMP->>FMP: Copy assets to src/main/resources/static/\n    Maven->>Maven: Package JAR with frontend assets\n    Maven-->>Dev: spring-modular-monolith.jar\n\n    Dev->>Spring: java -jar spring-modular-monolith.jar\n    Spring->>Spring: Serve frontend at /\n    Spring->>Spring: Serve APIs at /api/*\n```\n\n### API Type Generation Flow\n\n```mermaid\nsequenceDiagram\n    participant Dev as Frontend Developer\n    participant PNPM as pnpm gen:types\n    participant BE as Backend /api-docs\n    participant OT as openapi-typescript\n    participant FS as File System\n\n    Dev->>PNPM: pnpm gen:types\n    PNPM->>BE: GET http://localhost:8080/api-docs\n    BE-->>PNPM: OpenAPI 3.0 JSON spec\n    PNPM->>OT: Generate TypeScript types\n    OT->>OT: Parse schemas & paths\n    OT->>FS: Write to apps/web/lib/types/openapi.d.ts\n    FS-->>Dev: Type-safe API client ready\n```\n\n## Components and Interfaces\n\n### Component 1: Maven Frontend Build Integration\n\n**Purpose**: Automate frontend build as part of Maven lifecycle\n\n**Configuration**: `pom.xml`\n```xml\n<plugin>\n    <groupId>com.github.eirslett</groupId>\n    <artifactId>frontend-maven-plugin</artifactId>\n    <version>1.15.0</version>\n    <executions>\n        <execution>\n            <id>install node and pnpm</id>\n            <goals><goal>install-node-and-pnpm</goal></goals>\n            <configuration>\n                <nodeVersion>v18.20.0</nodeVersion>\n                <pnpmVersion>9.0.0</pnpmVersion>\n            </configuration>\n        </execution>\n        <execution>\n            <id>pnpm install</id>\n            <goals><goal>pnpm</goal></goals>\n            <configuration>\n                <arguments>install --frozen-lockfile</arguments>\n                <workingDirectory>frontend-nuxt</workingDirectory>\n            </configuration>\n        </execution>\n        <execution>\n            <id>pnpm build</id>\n            <goals><goal>pnpm</goal></goals>\n            <configuration>\n                <arguments>run build</arguments>\n                <workingDirectory>frontend-nuxt</workingDirectory>\n            </configuration>\n        </execution>\n    </executions>\n</plugin>\n\n<plugin>\n    <artifactId>maven-resources-plugin</artifactId>\n    <executions>\n        <execution>\n            <id>copy-frontend-assets</id>\n            <phase>prepare-package</phase>\n            <goals><goal>copy-resources</goal></goals>\n            <configuration>\n                <outputDirectory>${project.build.outputDirectory}/static</outputDirectory>\n                <resources>\n                    <resource>\n                        <directory>frontend-nuxt/apps/web/.next/standalone/apps/web</directory>\n                        <filtering>false</filtering>\n                    </resource>\n                    <resource>\n                        <directory>frontend-nuxt/apps/web/.next/static</directory>\n                        <targetPath>_next/static</targetPath>\n                        <filtering>false</filtering>\n                    </resource>\n                </resources>\n            </configuration>\n        </execution>\n    </executions>\n</plugin>\n```\n\n**Dependencies**: frontend-maven-plugin 1.15.0, Node.js 18+, pnpm 9.0+\n\n**Reuses**: Existing Maven build lifecycle and Spring Boot packaging\n\n### Component 2: CORS Configuration\n\n**Purpose**: Enable cross-origin requests during development\n\n**Implementation**: `src/main/java/com/sivalabs/bookstore/config/CorsConfig.java`\n\n```java\n@Configuration\n@Profile(\"dev\")\npublic class CorsConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\")\n            .allowedOrigins(\"http://localhost:3000\")\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")\n            .allowedHeaders(\"*\")\n            .allowCredentials(true)\n            .maxAge(3600);\n    }\n}\n```\n\n**Interfaces**:\n- Input: HTTP requests from `localhost:3000`\n- Output: CORS headers in HTTP responses\n\n**Dependencies**: Spring Web MVC, profile-based activation\n\n**Reuses**: Existing Spring Web MVC configuration infrastructure\n\n### Component 2.5: Session Cookie Configuration\n\n**Purpose**: Secure HTTP session cookies for production environments\n\n**Implementation**: `src/main/resources/application.properties`\n\n```properties\n# Session configuration\nserver.servlet.session.timeout=30m\nserver.servlet.session.cookie.name=BOOKSTORE_SESSION\nserver.servlet.session.cookie.http-only=true\nserver.servlet.session.cookie.secure=${USE_SECURE_COOKIES:false}\nserver.servlet.session.cookie.same-site=strict\n\n# Hazelcast session store\nspring.session.store-type=hazelcast\nspring.session.hazelcast.map-name=spring:session:sessions\n```\n\n**Profile-Specific Configuration** (`application-prod.properties`):\n```properties\nUSE_SECURE_COOKIES=true\nserver.servlet.session.cookie.domain=${FRONTEND_DOMAIN}\n```\n\n**Interfaces**:\n- Input: HTTP requests with session cookies\n- Output: Secure, HttpOnly session cookies\n\n**Dependencies**: Spring Session, Hazelcast\n\n**Reuses**: Existing Hazelcast configuration\n\n### Component 3: Enhanced HTTP Client\n\n**Purpose**: Provide type-safe API calls with error handling and session management\n\n**Migration Strategy**: The existing `http.ts` returns `{ data: T }` wrapper. We will enhance it in-place to maintain backward compatibility initially, then migrate to direct return types.\n\n**Current Implementation** (`apps/web/lib/http.ts`):\n```typescript\nexport const client = {\n  async GET<T = unknown>(path: string, init?: RequestInit): Promise<{ data: T }> {\n    const res = await fetch(path, { ...init });\n    if (!res.ok) throw new Error(`HTTP ${res.status}`);\n    return { data: await res.json() };\n  },\n  // ... POST method\n};\n```\n\n**Enhanced Implementation** (Phase 1 - Add alongside existing)\n\n```typescript\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';\n\nexport interface ApiError {\n  status: number;\n  message: string;\n  details?: unknown;\n}\n\nexport class HttpError extends Error {\n  constructor(public status: number, message: string, public details?: unknown) {\n    super(message);\n    this.name = 'HttpError';\n  }\n}\n\nexport const client = {\n  async GET<T = unknown>(path: string, init?: RequestInit): Promise<T> {\n    const res = await fetch(`${API_BASE_URL}${path}`, {\n      ...init,\n      credentials: 'include', // Include session cookie\n      headers: {\n        'Accept': 'application/json',\n        ...init?.headers,\n      },\n    });\n\n    if (!res.ok) {\n      const error = await res.json().catch(() => ({ message: res.statusText }));\n      throw new HttpError(res.status, error.message || res.statusText, error);\n    }\n\n    return res.json();\n  },\n\n  async POST<T = unknown>(path: string, body?: unknown, init?: RequestInit): Promise<T> {\n    const res = await fetch(`${API_BASE_URL}${path}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n        ...init?.headers,\n      },\n      credentials: 'include',\n      body: body ? JSON.stringify(body) : undefined,\n      ...init,\n    });\n\n    if (!res.ok) {\n      const error = await res.json().catch(() => ({ message: res.statusText }));\n      throw new HttpError(res.status, error.message || res.statusText, error);\n    }\n\n    return res.status === 204 ? undefined : res.json();\n  },\n\n  async PUT<T = unknown>(path: string, body?: unknown, init?: RequestInit): Promise<T> {\n    // Similar implementation to POST with method: 'PUT'\n  },\n\n  async DELETE<T = unknown>(path: string, init?: RequestInit): Promise<T> {\n    // Similar implementation to GET with method: 'DELETE'\n  },\n};\n```\n\n**Interfaces**:\n- Input: API path, request body (typed via OpenAPI)\n- Output: Typed response data or HttpError\n\n**Dependencies**: Fetch API, environment variables\n\n**Reuses**: Existing `http.ts` structure, extends with credentials and error handling\n\n### Component 4: OpenAPI Type Generation Script\n\n**Purpose**: Generate TypeScript types from backend OpenAPI specification\n\n**Implementation**: `frontend-nuxt/package.json` (updated scripts)\n\n**Migration Note**: The existing script uses a YAML file (`docs/specs/api/openapi.yaml`). We will support both modes:\n\n```json\n{\n  \"scripts\": {\n    \"gen:types\": \"openapi-typescript ${OPENAPI_SOURCE:-http://localhost:8080/api-docs} -o apps/web/lib/types/openapi.d.ts\",\n    \"gen:types:local\": \"openapi-typescript http://localhost:8080/api-docs -o apps/web/lib/types/openapi.d.ts\",\n    \"gen:types:spec\": \"openapi-typescript docs/specs/api/openapi.yaml -o apps/web/lib/types/openapi.d.ts\"\n  }\n}\n```\n\n**Recommended Workflow**:\n1. **Development**: Use `gen:types:local` - fetches live spec from running backend\n2. **CI/CD**: Use `gen:types:spec` - uses committed OpenAPI YAML file\n3. **Default**: Use `gen:types` - respects `OPENAPI_SOURCE` environment variable\n\n**Interfaces**:\n- Input: OpenAPI JSON from `/api-docs` or YAML file\n- Output: TypeScript definitions in `openapi.d.ts`\n\n**Dependencies**: `openapi-typescript` package (already in devDependencies)\n\n**Reuses**: Existing type generation workflow, adds HTTP endpoint support\n\n### Component 5: API Query Hooks with Generated Types\n\n**Purpose**: Type-safe TanStack Query hooks for API calls\n\n**Implementation**: `apps/web/features/books/api/queries.ts` (enhanced)\n\n```typescript\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { client } from '@/lib/http';\nimport type { paths } from '@/lib/types/openapi';\n\n// Extract types from OpenAPI schema\ntype ProductsResponse = paths['/api/products']['get']['responses']['200']['content']['application/json'];\ntype ProductResponse = paths['/api/products/{code}']['get']['responses']['200']['content']['application/json'];\n\nexport const qk = {\n  products: (params?: { page?: number }) => ['products', 'list', params ?? {}] as const,\n  product: (code: string) => ['products', 'detail', code] as const,\n};\n\nexport function useProducts(page: number = 1) {\n  return useQuery({\n    queryKey: qk.products({ page }),\n    queryFn: () => client.GET<ProductsResponse>(`/api/products?page=${page}`),\n  });\n}\n\nexport function useProduct(code: string) {\n  return useQuery({\n    queryKey: qk.product(code),\n    queryFn: () => client.GET<ProductResponse>(`/api/products/${code}`),\n  });\n}\n```\n\n**Interfaces**:\n- Input: Query parameters (page, code, etc.)\n- Output: Typed query results with loading/error states\n\n**Dependencies**: TanStack Query, enhanced HTTP client, generated OpenAPI types\n\n**Reuses**: Existing query key factory pattern, adds OpenAPI type constraints\n\n### Component 6: Static Resource Handler\n\n**Purpose**: Serve frontend assets and handle SPA routing\n\n**Implementation**: `src/main/java/com/sivalabs/bookstore/config/StaticResourceConfig.java`\n\n```java\n@Configuration\npublic class StaticResourceConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        // Serve Next.js static assets\n        registry.addResourceHandler(\"/_next/static/**\")\n            .addResourceLocations(\"classpath:/static/_next/static/\")\n            .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS).cachePublic());\n\n        // Serve other static assets\n        registry.addResourceHandler(\"/favicon.ico\", \"/images/**\", \"/css/**\")\n            .addResourceLocations(\"classpath:/static/\")\n            .setCacheControl(CacheControl.maxAge(7, TimeUnit.DAYS).cachePublic());\n    }\n\n    @Bean\n    @Order(Ordered.LOWEST_PRECEDENCE)\n    public WebMvcConfigurer spaRoutingConfigurer() {\n        return new WebMvcConfigurer() {\n            @Override\n            public void addViewControllers(ViewControllerRegistry registry) {\n                // Forward all non-API routes to index.html for SPA routing\n                registry.addViewController(\"/{spring:[^\\\\.]*}\")\n                    .setViewName(\"forward:/index.html\");\n            }\n        };\n    }\n}\n```\n\n**Interfaces**:\n- Input: HTTP requests to `/` paths (non-API)\n- Output: Static assets or index.html for SPA routing\n\n**Dependencies**: Spring Web MVC, classpath resources\n\n**Reuses**: Spring Boot's static resource serving, adds Next.js-specific paths\n\n## Data Models\n\n### Frontend-Backend DTO Mapping\n\nAll DTOs are defined in the backend and types are generated for frontend use:\n\n#### ProductDto\n```typescript\n// Generated from backend ProductDto\ninterface ProductDto {\n  code: string;\n  name: string;\n  description: string;\n  imageUrl: string;\n  price: number;\n}\n```\n**Backend Source**: `com.sivalabs.bookstore.catalog.api.ProductDto`\n\n#### CartDto\n```typescript\n// Generated from backend CartDto and CartItemDto\ninterface CartDto {\n  items: CartItemDto[];\n  totalAmount: number;\n  itemCount: number;\n}\n\ninterface CartItemDto {\n  code: string;\n  name: string;\n  price: number;\n  quantity: number;\n}\n```\n**Backend Source**: `com.sivalabs.bookstore.web.dto.{CartDto, CartItemDto}`\n\n#### OrderDto\n```typescript\n// Generated from backend OrderDto\ninterface CreateOrderRequest {\n  customer: {\n    name: string;\n    email: string;\n    phone: string;\n  };\n  deliveryAddress: string;\n  items: Array<{\n    code: string;\n    name: string;\n    price: number;\n    quantity: number;\n  }>;\n}\n\ninterface CreateOrderResponse {\n  orderNumber: string;\n}\n\ninterface OrderDto {\n  orderNumber: string;\n  status: string;\n  customer: Customer;\n  deliveryAddress: string;\n  items: OrderItem[];\n  createdAt: string;\n}\n```\n**Backend Source**: `com.sivalabs.bookstore.orders.api.{CreateOrderRequest, CreateOrderResponse, OrderDto}`\n\n#### PagedResult\n```typescript\n// Generated from backend PagedResult\ninterface PagedResult<T> {\n  data: T[];\n  totalElements: number;\n  pageNumber: number;\n  totalPages: number;\n  isFirst: boolean;\n  isLast: boolean;\n  hasNext: boolean;\n  hasPrevious: boolean;\n}\n```\n**Backend Source**: `com.sivalabs.bookstore.common.models.PagedResult`\n\n## Error Handling\n\n### Error Scenarios\n\n#### Scenario 1: Backend API Unreachable\n**Description**: Frontend cannot connect to backend (network error, backend down)\n**Handling**:\n- HTTP client catches fetch errors\n- Display user-friendly message: \"Unable to connect. Please check your connection.\"\n- TanStack Query provides automatic retry with exponential backoff (3 attempts)\n**User Impact**: Red error banner with retry button\n\n#### Scenario 2: Invalid API Response (4xx)\n**Description**: Client error (bad request, not found, validation error)\n**Handling**:\n- HTTP client throws `HttpError` with status code and backend error message\n- Frontend displays specific error from backend response body\n- Form validation errors highlighted inline\n**User Impact**: Inline error messages, form field highlights\n\n#### Scenario 3: Server Error (5xx)\n**Description**: Backend internal error, database connection failure\n**Handling**:\n- HTTP client throws `HttpError` with 5xx status\n- Display generic message: \"Something went wrong. Please try again later.\"\n- Error logged to console with full details for debugging\n**User Impact**: Generic error banner, option to retry\n\n#### Scenario 4: Session Timeout\n**Description**: User session expires during cart operation\n**Handling**:\n- Backend returns 401 or session-related error\n- Frontend detects session expiration\n- Display message: \"Your session has expired. Please refresh the page.\"\n- Cart state cleared on frontend\n**User Impact**: Session expiration notice, page refresh prompt\n\n#### Scenario 5: OpenAPI Type Generation Failure\n**Description**: Backend not running when `pnpm gen:types` executed\n**Handling**:\n- openapi-typescript fails with connection error\n- Display clear error message with instructions to start backend\n- Build process continues with stale types (if exists)\n**User Impact**: Developer sees error message, must start backend and retry\n\n### Error Response Format\n\nBackend error responses follow consistent structure:\n```json\n{\n  \"timestamp\": \"2025-10-18T17:00:00Z\",\n  \"status\": 400,\n  \"error\": \"Bad Request\",\n  \"message\": \"Product code is required\",\n  \"path\": \"/api/cart/items\"\n}\n```\n\nFrontend `HttpError` class captures this structure for consistent error handling.\n\n## Testing Strategy\n\n### Unit Testing\n\n#### Frontend Unit Tests\n- **HTTP Client Tests**: Test error handling, credentials, base URL configuration\n- **Query Hook Tests**: Test data fetching, caching, error states with MSW\n- **Component Tests**: Test UI components with mocked API responses\n\n**Tools**: Vitest, Testing Library, MSW\n\n**Coverage Target**: 80% for critical paths (API client, query hooks, cart logic)\n\n#### Backend Unit Tests (Existing)\n- REST controller tests already exist\n- DTO validation tests\n- Service layer tests\n\n**Reuses**: Existing test infrastructure in `src/test/java`\n\n### Integration Testing\n\n#### Frontend-Backend Integration\n- **Scenario**: Full user flow from browsing products to placing order\n- **Approach**: Start backend with Testcontainers (PostgreSQL), run Playwright E2E tests\n- **Key Flows**:\n  1. Browse products → Add to cart → View cart\n  2. Update cart quantity → Remove from cart\n  3. Fill order form → Submit order → View order confirmation\n\n**Tools**: Playwright, Testcontainers\n\n#### API Contract Testing\n- **Approach**: Validate frontend MSW mocks match backend OpenAPI spec\n- **Tool**: openapi-typescript with validation mode\n- **Frequency**: On every backend API change\n\n### End-to-End Testing\n\n#### E2E Test Scenarios\n1. **Happy Path**: Complete shopping flow with successful order\n2. **Error Handling**: Network errors, validation errors, session timeout\n3. **Session Persistence**: Cart survives page refresh\n4. **Browser Compatibility**: Chrome, Firefox, Safari (via Playwright)\n\n**Test Location**: `frontend-nuxt/apps/web/e2e/`\n\n**Reuses**: Existing Playwright configuration\n\n## Production Considerations\n\n### Build Optimization\n- Next.js production build with `output: 'standalone'` for minimal bundle\n- Static asset compression (gzip/brotli) via Spring Boot\n- Cache busting with content hashes in filenames\n- Bundle size budget: <500KB initial load (gzipped)\n\n### Session Management\n- Hazelcast distributed sessions for multi-instance deployment\n- Session timeout: 30 minutes (configurable)\n- Session cookie flags: HttpOnly, Secure (production), SameSite=Strict\n\n### Monitoring and Observability\n- Backend: Micrometer metrics, OpenTelemetry traces to HyperDX\n- Frontend: Web Vitals tracking (LCP, FID, CLS) - future enhancement\n- Health check: `/actuator/health` includes frontend asset verification\n\n### Security\n- CORS restricted to production domain\n- HTTPS enforced in production\n- CSP headers configured for Next.js assets\n- Session cookies secured with Secure flag\n\n### Scalability\n- Stateless backend instances (session in Hazelcast)\n- CDN-ready static asset structure\n- API response caching via HTTP cache headers\n- Database connection pooling (Hikari, max 10 connections per instance)\n",
  "fileStats": {
    "size": 25354,
    "lines": 767,
    "lastModified": "2025-10-18T17:08:27.985Z"
  },
  "comments": []
}