{
  "id": "snapshot_1760193705854_mavy8e2ne",
  "approvalId": "approval_1760189505311_z2101ory3",
  "approvalTitle": "Design: OpenAPI REST API Architecture",
  "version": 2,
  "timestamp": "2025-10-11T14:41:45.854Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design document outlines the implementation of a comprehensive REST API layer with OpenAPI documentation support for the BookStore Modular Monolith application. The solution adds `@RestController` endpoints that return JSON responses while coexisting with existing `@Controller` endpoints that return HTML views. The REST layer will reuse existing business logic through gRPC clients and service APIs, ensuring no duplication of business rules. The implementation follows Spring Boot best practices and maintains the modular architecture principles established in the codebase.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Framework Compatibility**:\n- Uses Spring Boot 3.5.5 with `springdoc-openapi-starter-webmvc-ui` (version 2.6.0 for Spring Boot 3.x compatibility)\n- Maintains Spring Modulith 1.4.3 module boundaries without modifications\n- Follows existing Java 21 language features and coding standards\n\n**Architecture Patterns**:\n- **Event-Driven**: REST layer observes same event patterns; order creation via REST publishes same `OrderCreatedEvent`\n- **Hexagonal Architecture**: REST controllers act as new adapters in the web layer, calling existing domain services\n- **API-based Integration**: REST controllers use `ProductApi` and `OrdersRemoteClient` (existing public APIs)\n\n**Code Quality**:\n- Adheres to Spotless + Palantir Java Format standards\n- Follows existing error handling patterns (`@RestControllerAdvice` similar to `CatalogExceptionHandler`)\n- Maintains >90% test coverage target with `@WebMvcTest` and `@SpringBootTest`\n\n### Project Structure (structure.md)\n\n**Module Organization**:\n```\nsrc/main/java/com/sivalabs/bookstore/\n├── catalog/\n│   └── web/\n│       ├── ProductRestController.java     # Enhanced with OpenAPI\n│       └── CatalogExceptionHandler.java   # Existing, will be referenced\n├── orders/\n│   └── web/\n│       ├── OrdersRestController.java      # NEW - REST API\n│       └── OrdersRestExceptionHandler.java # NEW - Error handling\n└── web/\n    ├── CartRestController.java            # NEW - REST API\n    └── OrdersWebController.java           # Existing, unchanged\n```\n\n**Configuration**:\n- OpenAPI config in `src/main/java/com/sivalabs/bookstore/config/OpenApiConfig.java`\n- Properties in existing `application.properties` (no new files)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**1. gRPC Client Infrastructure** (`orders` module):\n- **`OrdersRemoteClient`**: Will be injected into `OrdersRestController` for all order operations\n- **gRPC error handling**: Existing `StatusRuntimeException` handling patterns will be reused\n- **Retry/Circuit Breaker**: Existing gRPC client configuration applies to REST layer\n\n**2. Service APIs** (`catalog` module):\n- **`ProductService`**: Already used by `ProductRestController` for product queries\n- **`ProductMapper`**: Existing DTO mapping logic reused for REST responses\n- **`ProductApi`**: Public API used by `CartRestController` for product validation\n\n**3. Session Management** (`web` module):\n- **`CartUtil`**: Utility class for cart session management (already static methods)\n- **`Cart` and `Cart.LineItem`**: Existing data structures reused for cart operations\n- **Hazelcast Session Store**: Shared between Web Controllers and REST Controllers\n\n**4. Error Handling Patterns**:\n- **`CatalogExceptionHandler`**: Reference implementation for `@RestControllerAdvice` pattern\n- **`ProductNotFoundException`**: Existing exception will be caught by REST exception handlers\n- **HTTP status mapping**: Existing patterns from `OrdersWebController.handleGrpcStatusException()`\n\n### Integration Points\n\n**1. Existing gRPC Server** (port 9091):\n- REST Controllers → `OrdersRemoteClient` → gRPC Server (localhost:9091)\n- No changes to gRPC proto definitions or server implementation\n- REST layer acts as additional client of existing gRPC services\n\n**2. Database Schemas**:\n- No direct database access from REST layer\n- All database operations through existing services (`ProductService`, gRPC for orders)\n- Maintains schema isolation (catalog, orders, inventory schemas)\n\n**3. Event Publishing**:\n- REST-created orders trigger same `OrderCreatedEvent` as Web Controller\n- Events flow through existing Spring Modulith event bus\n- RabbitMQ external publishing unchanged\n\n## Architecture\n\nThe design follows a **layered adapter pattern** where REST controllers act as thin HTTP adapters over existing business logic. No business rules are duplicated; all operations delegate to existing services and clients.\n\n### Architectural Principles\n\n**1. Separation of Concerns**:\n- `@Controller` (Web): Handle form submissions, return HTML views (unchanged)\n- `@RestController` (REST API): Handle JSON requests, return JSON responses (new layer)\n- Business Logic: Remains in services, gRPC clients, and domain modules (unchanged)\n\n**2. Coexistence Strategy**:\n- Both controller types share same session management (Hazelcast)\n- Both use same DTOs where applicable (`ProductDto`, `OrderDto`)\n- URL namespacing: `/api/*` for REST, `/*` for Web\n\n**3. Error Handling Hierarchy**:\n```\nREST Controllers\n    ↓ (delegates to)\nServices/gRPC Clients\n    ↓ (throws domain exceptions)\n@RestControllerAdvice\n    ↓ (maps to HTTP responses)\nErrorResponse DTO\n```\n\n### System Architecture Diagram\n\n```mermaid\ngraph TD\n    subgraph Frontend Layer\n        SPA[SPA Applications]\n        Browser[Traditional Browser]\n    end\n\n    subgraph API Layer\n        RestAPI[REST Controllers<br/>@RestController]\n        WebCtrl[Web Controllers<br/>@Controller]\n    end\n\n    subgraph Business Layer\n        GrpcClient[OrdersRemoteClient<br/>gRPC Client]\n        ProdAPI[ProductApi]\n        CartUtil[CartUtil]\n    end\n\n    subgraph Infrastructure\n        GrpcServer[gRPC Server<br/>port 9091]\n        Session[Hazelcast Session]\n        DB[(PostgreSQL)]\n    end\n\n    SPA -->|JSON| RestAPI\n    Browser -->|HTML Forms| WebCtrl\n\n    RestAPI -->|Delegates| GrpcClient\n    RestAPI -->|Delegates| ProdAPI\n    RestAPI -->|Uses| CartUtil\n\n    WebCtrl -->|Delegates| GrpcClient\n    WebCtrl -->|Uses| ProdAPI\n    WebCtrl -->|Uses| CartUtil\n\n    GrpcClient -->|Protocol Buffers| GrpcServer\n    ProdAPI -->|JPA| DB\n    CartUtil -->|Session| Session\n    GrpcServer -->|JPA| DB\n```\n\n## Components and Interfaces\n\n### Component 1: OpenApiConfig (Configuration)\n\n- **Purpose:** Configure SpringDoc OpenAPI documentation and Swagger UI\n- **Location:** `src/main/java/com/sivalabs/bookstore/config/OpenApiConfig.java`\n- **Interfaces:**\n  - `@Bean OpenAPI customOpenAPI()` - Defines API metadata\n  - Returns `OpenAPI` object with title, version, description, servers\n- **Dependencies:** `springdoc-openapi-starter-webmvc-ui` library\n- **Reuses:** Reads application properties for server URL configuration\n\n```java\n@Configuration\npublic class OpenApiConfig {\n    @Bean\n    public OpenAPI customOpenAPI() {\n        return new OpenAPI()\n            .info(new Info()\n                .title(\"BookStore REST API\")\n                .version(\"1.0.0\")\n                .description(\"REST API for BookStore Modular Monolith\"))\n            .servers(List.of(new Server().url(\"http://localhost:8080\")));\n    }\n}\n```\n\n### Component 2: Enhanced ProductRestController\n\n- **Purpose:** Provide REST API for product catalog with OpenAPI documentation\n- **Location:** `src/main/java/com/sivalabs/bookstore/catalog/web/ProductRestController.java` (existing, enhanced)\n- **Interfaces:**\n  - `GET /api/products?page={page}` → `PagedResult<ProductDto>`\n  - `GET /api/products/{code}` → `ProductDto`\n- **Dependencies:** `ProductService`, `ProductMapper`\n- **Reuses:** Existing service layer, DTO mapping logic\n\n**OpenAPI Annotations:**\n```java\n@Tag(name = \"Products\", description = \"Product catalog management API\")\n@Operation(summary = \"Get paginated products\")\n@ApiResponses({\n    @ApiResponse(responseCode = \"200\", description = \"Successfully retrieved\"),\n    @ApiResponse(responseCode = \"400\", description = \"Invalid page parameter\")\n})\n```\n\n### Component 3: CartRestController (New)\n\n- **Purpose:** Provide REST API for shopping cart operations\n- **Location:** `src/main/java/com/sivalabs/bookstore/web/CartRestController.java`\n- **Interfaces:**\n  - `POST /api/cart/items` - Add item to cart\n  - `PUT /api/cart/items/{code}` - Update item quantity\n  - `GET /api/cart` - Get cart contents\n  - `DELETE /api/cart` - Clear cart\n- **Dependencies:** `ProductApi`, `CartUtil` (existing)\n- **Reuses:** Session management via `HttpSession`, existing `Cart` model\n\n**Implementation Pattern:**\n```java\n@RestController\n@RequestMapping(\"/api/cart\")\n@Tag(name = \"Cart\", description = \"Shopping cart management API\")\npublic class CartRestController {\n    private final ProductApi productApi;\n\n    @PostMapping(\"/items\")\n    public ResponseEntity<CartDto> addItem(\n        @Valid @RequestBody AddToCartRequest request,\n        HttpSession session\n    ) {\n        Cart cart = CartUtil.getCart(session);\n        ProductDto product = productApi.getByCode(request.code()).orElseThrow();\n        // Add to cart logic\n        return ResponseEntity.ok(mapToDto(cart));\n    }\n}\n```\n\n### Component 4: OrdersRestController (New)\n\n- **Purpose:** Provide REST API for order management, delegating to gRPC\n- **Location:** `src/main/java/com/sivalabs/bookstore/orders/web/OrdersRestController.java`\n- **Interfaces:**\n  - `POST /api/orders` → `CreateOrderResponse` (HTTP 201)\n  - `GET /api/orders` → `List<OrderView>`\n  - `GET /api/orders/{orderNumber}` → `OrderDto`\n- **Dependencies:** `OrdersRemoteClient` (existing gRPC client)\n- **Reuses:** gRPC client, existing DTOs, session management\n\n**gRPC Error Mapping:**\n```java\n@RestController\n@RequestMapping(\"/api/orders\")\npublic class OrdersRestController {\n    private final OrdersRemoteClient ordersClient;\n\n    @PostMapping\n    public ResponseEntity<CreateOrderResponse> createOrder(\n        @Valid @RequestBody CreateOrderRequest request\n    ) {\n        try {\n            CreateOrderResponse response = ordersClient.createOrder(request);\n            return ResponseEntity.status(HttpStatus.CREATED).body(response);\n        } catch (StatusRuntimeException ex) {\n            // Map gRPC status to HTTP status (reuse existing logic)\n            throw mapGrpcException(ex);\n        }\n    }\n}\n```\n\n### Component 5: OrdersRestExceptionHandler (New)\n\n- **Purpose:** Unified error handling for REST API endpoints\n- **Location:** `src/main/java/com/sivalabs/bookstore/orders/web/OrdersRestExceptionHandler.java`\n- **Interfaces:**\n  - `@ExceptionHandler` methods for domain exceptions\n  - Returns `ResponseEntity<ErrorResponse>`\n- **Dependencies:** None (handles exceptions globally)\n- **Reuses:** Error mapping patterns from `OrdersWebController.handleGrpcStatusException()`\n\n**Error Response Format:**\n```java\npublic record ErrorResponse(\n    @Schema(description = \"HTTP status code\") int status,\n    @Schema(description = \"Error message\") String message,\n    @Schema(description = \"Timestamp\") LocalDateTime timestamp\n) {}\n\n@RestControllerAdvice(assignableTypes = OrdersRestController.class)\npublic class OrdersRestExceptionHandler {\n    @ExceptionHandler(OrderNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleOrderNotFound(OrderNotFoundException ex) {\n        return ResponseEntity.status(HttpStatus.NOT_FOUND)\n            .body(new ErrorResponse(404, ex.getMessage(), LocalDateTime.now()));\n    }\n}\n```\n\n## Data Models\n\n### CartDto (New)\n\n```java\n@Schema(description = \"Shopping cart with items and total\")\npublic record CartDto(\n    @Schema(description = \"Cart items\", required = true)\n    List<CartItemDto> items,\n\n    @Schema(description = \"Total amount\", example = \"99.99\")\n    BigDecimal totalAmount,\n\n    @Schema(description = \"Number of items in cart\", example = \"3\")\n    int itemCount\n) {}\n```\n\n### CartItemDto (New)\n\n```java\n@Schema(description = \"Shopping cart line item\")\npublic record CartItemDto(\n    @Schema(description = \"Product code\", example = \"P001\")\n    String code,\n\n    @Schema(description = \"Product name\", example = \"Spring Boot in Action\")\n    String name,\n\n    @Schema(description = \"Unit price\", example = \"29.99\")\n    BigDecimal price,\n\n    @Schema(description = \"Quantity\", example = \"2\", minimum = \"1\")\n    @Min(1) int quantity,\n\n    @Schema(description = \"Subtotal (price * quantity)\", example = \"59.98\")\n    BigDecimal subtotal\n) {}\n```\n\n### AddToCartRequest (New)\n\n```java\n@Schema(description = \"Request to add item to cart\")\npublic record AddToCartRequest(\n    @Schema(description = \"Product code\", required = true, example = \"P001\")\n    @NotBlank String code,\n\n    @Schema(description = \"Quantity to add\", required = true, example = \"1\", minimum = \"1\")\n    @Min(1) int quantity\n) {}\n```\n\n### UpdateQuantityRequest (New)\n\n```java\n@Schema(description = \"Request to update cart item quantity\")\npublic record UpdateQuantityRequest(\n    @Schema(description = \"New quantity\", required = true, example = \"3\", minimum = \"1\")\n    @Min(1) int quantity\n) {}\n```\n\n### ErrorResponse (New)\n\n```java\n@Schema(description = \"Error response format\")\npublic record ErrorResponse(\n    @Schema(description = \"HTTP status code\", example = \"404\")\n    int status,\n\n    @Schema(description = \"Error message\", example = \"Order not found\")\n    String message,\n\n    @Schema(description = \"Error timestamp\", example = \"2025-10-11T12:00:00\")\n    LocalDateTime timestamp\n) {}\n```\n\n### Enhanced Existing DTOs\n\n**ProductDto** (add `@Schema` annotations):\n```java\n@Schema(description = \"Product information\")\npublic record ProductDto(\n    @Schema(description = \"Product code\", example = \"P001\")\n    String code,\n\n    @Schema(description = \"Product name\", example = \"Spring Boot in Action\")\n    String name,\n\n    @Schema(description = \"Product price\", example = \"29.99\")\n    BigDecimal price,\n\n    @Schema(description = \"Product image URL\")\n    String imageUrl\n) {}\n```\n\n**OrderDto, OrderView, CreateOrderRequest, CreateOrderResponse** (add `@Schema` annotations to all fields)\n\n## Error Handling\n\n### Error Scenarios\n\n#### 1. Product Not Found\n- **Description:** Client requests non-existent product code\n- **Handling:**\n  - `ProductApi.getByCode()` returns `Optional.empty()`\n  - Throw `ProductNotFoundException.forCode(code)`\n  - `@ExceptionHandler` catches and returns 404\n- **User Impact:** Receives `{\"status\": 404, \"message\": \"Product with code 'INVALID' not found\", \"timestamp\": \"...\"}`\n\n#### 2. gRPC Communication Failure\n- **Description:** Orders gRPC server is unavailable or unresponsive\n- **Handling:**\n  - `OrdersRemoteClient` throws `StatusRuntimeException`\n  - Map gRPC status codes: `UNAVAILABLE` → HTTP 503, `DEADLINE_EXCEEDED` → HTTP 504\n  - Include retry guidance in error message\n- **User Impact:** Receives `{\"status\": 503, \"message\": \"Orders service unavailable. Please retry.\", \"timestamp\": \"...\"}`\n\n#### 3. Invalid Request Data\n- **Description:** Client sends malformed JSON or fails validation\n- **Handling:**\n  - Spring Validation throws `MethodArgumentNotValidException`\n  - `@ExceptionHandler` extracts field errors\n  - Return HTTP 400 with field-level error details\n- **User Impact:** Receives `{\"status\": 400, \"message\": \"Validation failed: quantity must be >= 1\", \"timestamp\": \"...\"}`\n\n#### 4. Session Cart Not Found\n- **Description:** Client tries to access cart without valid session\n- **Handling:**\n  - `CartUtil.getCart()` always returns cart (creates if missing)\n  - No error case for missing cart (empty cart returned)\n- **User Impact:** Receives empty cart response `{\"items\": [], \"totalAmount\": 0.00, \"itemCount\": 0}`\n\n#### 5. Order Creation Business Rule Violation\n- **Description:** gRPC server rejects order due to business rules (e.g., insufficient stock)\n- **Handling:**\n  - gRPC returns `FAILED_PRECONDITION` or `INVALID_ARGUMENT`\n  - Map to HTTP 400 with descriptive message from gRPC error details\n  - Parse `status.getDescription()` for business rule message\n- **User Impact:** Receives `{\"status\": 400, \"message\": \"Insufficient stock for product P001\", \"timestamp\": \"...\"}`\n\n## Testing Strategy\n\n### Unit Testing\n\n**ProductRestController Tests** (`ProductRestControllerTests.java`):\n- Mock `ProductService` and `ProductMapper`\n- Test pagination logic with various page numbers\n- Test product-by-code lookup (found and not found cases)\n- Verify OpenAPI annotations are present (via reflection or Swagger JSON validation)\n\n**CartRestController Tests** (`CartRestControllerTests.java`):\n- Mock `ProductApi` and `HttpSession`\n- Test add-to-cart with valid/invalid product codes\n- Test quantity update with boundary values (1, Integer.MAX_VALUE, 0)\n- Test cart retrieval and clearing\n- Verify session interaction (CartUtil usage)\n\n**OrdersRestController Tests** (`OrdersRestControllerTests.java`):\n- Mock `OrdersRemoteClient`\n- Test order creation success path\n- Test gRPC error mapping (UNAVAILABLE → 503, INVALID_ARGUMENT → 400, etc.)\n- Test order retrieval and list operations\n- Verify JSON serialization of gRPC responses\n\n**Exception Handler Tests** (`OrdersRestExceptionHandlerTests.java`):\n- Test all `@ExceptionHandler` methods\n- Verify HTTP status codes and error response format\n- Test gRPC exception mapping completeness\n- Validate error messages don't leak internal details\n\n### Integration Testing\n\n**REST API Integration Tests** (`RestApiIntegrationTests.java`):\n- Use `@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)`\n- Use `TestRestTemplate` or `WebTestClient`\n- Test full request-response cycles (JSON in, JSON out)\n- Verify session persistence across requests (cart operations)\n- Test gRPC integration with Testcontainers (if gRPC server mocked)\n\n**OpenAPI Specification Tests** (`OpenApiSpecificationTests.java`):\n- Load generated OpenAPI JSON from `/api-docs`\n- Validate against OpenAPI 3.0 schema\n- Verify all endpoints are documented\n- Check for required fields in request/response schemas\n- Ensure error responses are documented\n\n**Cross-Controller Tests** (`RestAndWebCoexistenceTests.java`):\n- Verify Web Controllers and REST Controllers can coexist\n- Test session sharing (add to cart via Web, retrieve via REST API)\n- Verify both layers work independently\n- Test URL routing doesn't conflict (`/products` vs `/api/products`)\n\n### End-to-End Testing\n\n**Shopping Flow E2E Test** (`ShoppingFlowE2ETests.java`):\n1. GET `/api/products` - Retrieve product list\n2. POST `/api/cart/items` - Add product to cart\n3. GET `/api/cart` - Verify cart contents\n4. POST `/api/orders` - Create order from cart\n5. GET `/api/orders/{orderNumber}` - Verify order details\n6. Verify event publishing (check `OrderCreatedEvent` in test event listener)\n\n**Error Handling E2E Test** (`ErrorHandlingE2ETests.java`):\n- Test 404 path: Request invalid product code\n- Test 400 path: Send invalid JSON, violate validation rules\n- Test 503 path: Simulate gRPC service down (via chaos engineering or mock)\n- Verify all error responses match ErrorResponse schema\n\n**SDK Generation Test** (`SdkGenerationTests.java`):\n- Export OpenAPI spec to file\n- Run `openapi-generator-cli` to generate TypeScript SDK\n- Compile generated SDK (verify no TypeScript errors)\n- Test basic SDK usage against running server\n",
  "fileStats": {
    "size": 19272,
    "lines": 517,
    "lastModified": "2025-10-11T13:31:37.724Z"
  },
  "comments": []
}